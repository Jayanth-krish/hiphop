<!-- ${ var doc = require( "hopdoc" ) } -->

HipHop Environment
==================

> [!NOTE]
> The source files used in this chapter are avaiable in the HipHop
> [github](https://github.com/manuel-serrano/hiphop/tree/master/examples/web) 
> repository.

Running HipHop programs 
-----------------------

In this chapter, we show how to run HipHop programs on a server-side
of an application, e.g., on Nodejs, and on the client-side of a web
application, .e.g., on Firefox. To run the examples, first create a
fresh directory and install HipHop inside it.

```shell
mkdir example
cd example
npm install https://www-sop.inria.fr/members/Manuel.Serrano/software/npmx/hiphop.tgz
```

In the rest of this section we assume the file `abro.hh.js` defined as:

&#x2605; [abro.hh.mjs](../examples/web/abro.hh.mjs)
<!-- ${doc.includeCode("../examples/web/abro.hh.mjs", "hopscript")} -->

### Server-side execution ###

To execute a HipHop program on an unmodified JavaScript execution engines,
let it be Nodejs, Hop, or any other compliant engine, it has to be
compiled first. This is accomplished by the `hhc.mjs` compiler that
is part of the standard HipHop distribution. To compile our `abro.hh.js`
example, one has to use the following command:

```shell
./node_module/@hop/hiphop/bin/hhc.mjs abro.hh.mjs -o abro.mjs
```

This will generate two files:

  * `abro.mjs`, which a standard JavaScript ES6 module.
  * `abro.map.json`, which is a _source map_ file that will let the
  native JavaScript engine refer to source location inside `abro.hh.js`
  instead of `abro.mjs`.

Once, compiled, the program can be imported by any regular ES6 module
and executed using the HipHop API. Example:

&#x2605; [hello.mjs](../examples/web/hello.mjs)
<!-- ${doc.includeCode("../examples/web/hello.mjs", "hopscript")} -->

This program can be executed with:

```shell
nodejs --enable-source-maps hello.mjs 
```

### Client-side execution with a Nodejs server ###

In this section we show how to use HipHop on client-side of web
applications. We show how to proceed to implement a web app executing
the `abro.hh.mjs` reactive program on a web browser. Let's implement a
minimal web server only using the bare
Nodejs' [http](https://nodejs.org/docs/latest/api/http.html) api.

Let us first describe the web page the server delivers.

&#x2605; [index.html](../examples/web/index.html)
<!-- ${doc.includeCode("../examples/web/index.html", "xml")} -->

The `script type="importmap"` specify a mapping from JavaScript module
names to URL. As such, when the JavaScript code running on the browser
will import the module `@hop/hiphop`, the browser will request the URL
`/hiphop.mjs` to the server (we'll see in a moment how we configure
the server so that it can respond to this request). By specifying a
module-to-URL mapping, we can re-use the same program `abro.mjs`
as the one we use when running on the server, althought the module
`@hop/hiphop` has different implementations for the server and for the
client.

The configuration of the web server is as follows:

&#x2605; [node-server.mjs](../examples/web/node-server.mjs)
<!-- ${doc.includeCode("../examples/web/node-server.mjs", "hopscript")} -->

It is a standard implementation of a web server using Nodejs and contains
no code specific to HipHop.

### Client-side execution with a Hop Server ###

We can simplify the implementation of our simple HipHop web
application by using a [hop](https://github.com/manuel-serrano/hop)
server instead of a plain Nodejs server.

As for the previous example, the Hiphop `abro.hh.mjs` file remain unchanged.
In Hop, the standard way to generate HTML documents is to build them
dynamically using the builtin XML syntax. The HTML page will be then
generated by the `index` function defined as:

&#x2605; [index.hop.mjs](../examples/web/index.hop.mjs)
<!-- ${doc.includeCode("../examples/web/index.hop.mjs", "hopscript")} -->

Before being executed, this module has to be compiled to plain JavaScript

```shell
./node_modules/@hop/hop/bin/hopc index.hop.mjs -o index.mjs
```

The main difference with the static document we have used for Nodejs is
the use of the `R` variable. The Nodejs version was only able to deliver
a fixed set of files and the mapping between URL and files was fixed once
for all at the initialization of the program. Hop uses a more elaborated
mechanism for implementing the mapping. The only useful information here
is that `R` is a bidirectional data structure mapping actual file names
to URL and vice-versa.

The server-side module is defined as follows:

&#x2605; [hop-server.mjs](../examples/web/hop-server.mjs)
<!-- ${doc.includeCode("../examples/web/hop-server.mjs", "hopscript")} -->

Visualizing the Net List
------------------------

The HipHop compiler generates a net list from a HipHop source. This compiled
program can be executed by simulating the generated circuit. The tools
`tools/nets2dot.mjs` can be used in conjunction with the 
[dot](https://graphviz.org) graph visualizer to generate PDF files.
Here is how to proceed for generating these files, considering a HipHop
source file named `foo.hh.js`:

  1. Add the option `{ dumpNets: true }` to the reactive machine for 
  which you want to dump the net list.
  2. Run your program. This will generate two files: `foo.hh.js.nets-.json`
  and `foo.hh.js.nets+.json`. The former is the net list before optimization
  the latter with optimization.
  3. Generate the `.dot` files:
    - bin/nets2dot.js foo.hh.js.nets-.json > nets-.dot
    - bin/nets2dot.js foo.hh.js.nets+.json > nets+.dot
  4. Generate the PDF files:
    - dot -T pdf nets-.dot > nets-.pdf
    - dot -T pdf nets+.dot > nets+.pdf
